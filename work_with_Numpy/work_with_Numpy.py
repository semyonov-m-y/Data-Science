import numpy as np

a = np.array([1, 2, 3])
a2 = np.array([[1, 2, 3], [4, 5, 6]])
a3 = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(a)
print(a2)
print(a3)

b = np.array([1.4, 2.5, 3.7])
print(b)

c = np.array([1, 2, 3], dtype='float32')
print(c)

d = np.array([1,2,3], dtype='int32')
#Чтобы узнать, сколько у объекта d измерений, воспользуемся функцией ndim:
print(a.ndim) #Всё верно 1, ведь у нас одномерный массив, или вектор.

#посчитать количество строк и столбцов
print(d.shape) #вектор — это всего лишь одномерный массив. У векторов в библиотеке NumPy есть только строки — или элементы. Поэтому функция shape выдала число 3.

e = np.array([[1, 2, 3], [4, 5, 6]])
print(e.shape) #В b — 2 строки и 3 столбца.

#Для трёхмерных и n-мерных массивов функция shape будет добавлять дополнительные цифры в кортеже через запятую:
f = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(f.shape) #Читается это так: в объекте c два трёхмерных массива с двумя строками и тремя столбцами.

#Кроме размерностей, можно также узнать тип элементов — в этом поможет функция dtype (не путайте её с одноимённым параметром):
g = np.array([1,2,3], dtype='int32')
print(g.dtype) #Если не присваивать тип элементам вручную, по умолчанию будет задан int32.

#Ещё можно узнать количество элементов с помощью функции size:
print(g.size)

#А через функции itemsize и nbytes можно узнать, какое количество байт в памяти занимает один элемент и какое количество байт занимает весь массив:
h = np.array([[1, 2, 3], [4, 5, 6]], dtype='int16')
print(h.itemsize) #Один элемент занимает 2 байта,
print(h.nbytes) # а весь объект b из 6 элементов — 2 × 6 = 12 байтов.

#Доступ к элементам
#В NumPy можно обращаться к отдельным элементам, строкам или столбцам, а также точечно выбирать последовательность нужных элементов.
i = np.array([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14]])
#И мы хотим достать их него элемент, который находится в первой строке на пятом месте. Сделать это можно с помощью специального оператора []:
print(i[0, 4])

#Если бы у нас был трёхмерный массив, обращение к его элементам было бы похожим:
j = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(j[1, 1, 1]) #Здесь мы сначала обратились ко второму двумерному массиву, а затем выбрали в нём вторую строку и второй столбец. Там и находилось число 11.

#Кроме отдельных элементов, в библиотеке NumPy можно обратиться к целой строке или столбцу с помощью оператора :. Он позволяет выбрать все элементы указанной строки или столбца:
print(j[0, :]) #[1 2 3 4 5 6 7]
print(j[:, 0]) #[1 8]
#В первом случае мы выбрали всю первую строку, а во втором — первый столбец.

# Ещё можно использовать продвинутые способы выделения нужных нам элементов. Кстати, оператор : на самом деле представляет собой сокращённую форму конструкции начальный_индекс: конечный_индекс: шаг.
k = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(k[0, 1:4:2]) #[2 4] Мы указали, что хотим выбрать первую строку, а затем уточнили, какие именно столбцы нам нужны: 1:4:2.
'''
Первое число означает, что мы начинаем брать элементы с первого индекса — второго столбца.
Второе число — что мы заканчиваем итерацию на четвёртом индексе, то есть проходим всю строку.
Третье число указывает, с каким шагом мы идём по строке. В нашем примере — с шагом в два элемента. То есть мы пройдём по элементам 1, 3 и 5.
Давайте посмотрим на другой пример:
'''
l = np.array([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14]])
print(l[1, 0:-1:3]) #[8, 11] Здесь мы использовали отрицательные индексы — они позволяют считать индексы элементов справа налево. –1 означает, что последний индекс — это последний столбец второй строки. Заметьте, что 6-й столбец не вывелся. Это значит, что NumPy не доходит до этого индекса, а заканчивает обход на один индекс раньше.

#Ещё мы можем менять значения в NumPy-массиве с помощью той же операции доступа к элементам.
m = np.array([[0, 2], [4, 6]])
m[0, 0] = 1
print(m) #[[1 2][4 6]] Мы заменили элемент из первой строки и первого столбца (элемент 0) на единицу.

#Кроме отдельных элементов, можно заменять любые последовательности элементов с помощью конструкции начальный_индекс: конечный_индекс: шаг и её упрощённой версии — :.
n = np.array([[0, 2], [4, 6]])
n[0, :] = [3, 3]
print(n) #[[3 3][4 6]] Теперь в с вся первая строка заменилась на тройки. Главное при такой замене — учитывать размер строки, чтобы не возникло ошибок. Например, если присвоить первой строке вектор из трёх элементов, интерпретатор будет ругаться:

#Создание специальных массивов
#Мы научились создавать массивы любой размерности. Но иногда хочется создать их с уже заполненными значениями — например, забить все ячейки нулями или единицами.
#Массив из нулей. Чтобы создать его, используем функцию zeros.
o = np.zeros((2, 2))
print(o) #[[0. 0.][0. 0.]] Первое, что нужно помнить, — как задавать размер. Он задаётся кортежем (2, 2). Если указать размер без скобок, то снова получим ошибку

#Если указать только одно число, создастся вектор размером два элемента. В этом случае уже не нужно ставить дополнительные скобки:
p = np.zeros(2)
print(p) #[0. 0.]

#Ещё стоит отметить, что элементам по умолчанию присваивается тип float64. Это дробные числа, которые занимают в памяти 64 бита, или 8 байт. Если нужны именно целые числа, то мы по старой схеме указываем это в параметре dtype — через запятую:
r = np.zeros(2, dtype='int32')
print(r) #[0 0]

#Массив из единиц. Он создаётся точно так же, как и из нулей, но используется функция ones:
s = np.ones((4, 2, 2), dtype='int32')
print(s) #[[[1 1][1 1]][[1 1][1 1]][[1 1][1 1]][[1 1][1 1]]] Здесь мы создали трёхмерный массив из четырёх двумерных, каждый из которых имеет две строки и два столбца. А также указали, что элементы должны иметь тип int32.

#Массив из произвольных чисел. Иногда бывает нужно заполнить массив какими-то отличными от нуля и единицы числами. В этом поможет функция full:
t = np.full((2, 2), 5)
print(t) #[[5 5][5 5]] Здесь мы сначала указали, какой размер должен быть у массива через кортеж, — (2,2), а затем число, которым мы хотим заполнить все его элементы, — 5.
#Равно как и у функций zeros и ones, элементы по умолчанию будут иметь тип float64. А размер должен передаваться в виде кортежа — (2, 2).

#Массив случайных чисел. Он создаётся с помощью функции random.rand:
u = np.random.rand(3, 2)
print(u) #[[0.76088962 0.14281283][0.32124888 0.34894434][0.66903093 0.72899792]] Получилось что-то странное. Но так и должно быть — ведь NumPy генерирует случайные числа в диапазоне от 0 до 1 с восемью знаками после запятой.
#Ещё одна странность — то, как задаётся размер. Здесь это нужно делать не через кортеж (3, 2), а просто указывая размерности через запятую. Всё потому, что в функции random.rand нет параметра dtype.

#Чтобы создать массив случайных чисел, нужно воспользоваться функцией random.randint:
y = np.random.randint(-5, 10, size=(4, 4))
print(y) #[[ 3  1 -4  3][ 0 -2  5  3][ 5 -1  9  2][ 0 -4  9 -2]]
#У нас получился массив размером четыре на четыре — size=(4, 4) — с целыми числами из диапазона от –5 до 10. Как и в предыдущем случае, создаётся такой массив слегка странно — но такова жизнь NumPy-программистов.

#Единичная матрица. Она нужна тем, кто занимается линейной алгеброй. По диагонали такой матрицы элементы равны единице, а все остальные элементы — нулю. Создаётся она с помощью функции identity или eye:
v = np.identity(4, dtype='int32')
print(v) #[[1. 0. 0. 0.][0. 1. 0. 0.][0. 0. 1. 0.][0. 0. 0. 1.]] Здесь задаётся только количество строк матрицы, потому что единичная матрица должна быть симметричной — иметь одинаковое количество строк и столбцов.

#Математические операции
#Массивы из NumPy поддерживают все стандартные арифметические операции — например, сложение, деление, вычитание. Работает это поэлементно:
x = np.array([1, 2, 3, 4])
print(x + 3) #[4 5 6 7] К каждому элементу a прибавилось число 3, а размерность не изменилась. Все остальные операции работают точно так же:
print(x - 2) #[-1 0 1 2]
print(x * 2) #[2 4 6 8]
print(x / 2) #[0.5 1. 1.5 2.] Здесь тип элементов приведён к 'float64'
print(x ** 2) #[1 4 9 16]

#Ещё можно проводить любые математические операции с массивами одинакового размера:
w = np.array([[1, 2], [3, 4]])
z = np.array([[2, 2], [2, 2]])
print(w + z) #[[3 4][5 6]]
print(w * z) #[[2 4][6 8]]
print(w ** z) #[[ 1  4][ 9 16]]
#Здесь каждый элемент w складывается, умножается и возводится в степень на элемент из такой же позиции массива z.

#Кроме примитивных операций, в NumPy можно проводить и более сложные — например, вычислить косинус:
z1 = np.array([[1, 2], [3, 4]])
print(np.cos(z1)) #[[ 0.54030231 -0.41614684][-0.9899925  -0.65364362]]

#Ещё к массивам можно применять различные операции из линейной алгебры, математической статистики и так далее. Давайте для примера перемножим матрицы по правилам линейной алгебры:
x1 = np.ones((2, 3))
print(x1) #[[1. 1. 1.][1. 1. 1.]]
y1 = np.full((3, 2), 2)
print(y1) #[[2 2][2 2][2 2]]
print(np.matmul(x1, y1)) #[[6. 6.][6. 6.]]

#Копирование и организация
#Если в NumPy вы присвоите массив другой переменной, то просто создадите ссылку на него. Разберём на примере:
w1 = np.array([1, 2, 3])
v1 = w1
v1[0] = 5
print(v1) #[5 2 3]
print(w1) #[5 2 3]
#Как мы видим, при изменении v1 меняется также и w1. Дело в том, что массивы в NumPy — это только ссылки на области в памяти. Поэтому, когда мы присвоили w1 переменной v1, на самом деле мы просто присвоили ей ссылку на первый элемент w1 в памяти.

#Чтобы создать независимую копию w1, используйте функцию copy:
w1 = np.array([1, 2, 3])
v1 = w1.copy()
v1[0] = 5
print(v1) #[5 2 3]
print(w1) #[1 2 3]

#Ещё мы можем менять размер массива с помощью функции reshape:
u1 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(u1) #[[1 2 3 4][5 6 7 8]]
t1 = u1.reshape((4, 2))
print(t1) #[[1 2][3 4][5 6][7 8]]
#Изначально размер u1 был 2 на 4. Мы переделали его под 4 на 2. Заметьте: новые размеры должны соответствовать количеству элементов. В противном случае Python вернет ошибку

#Ещё NumPy позволяет нам «наслаивать» массивы друг на друга и соединять их с помощью функций vstack и hstack:
s1 = np.array([1, 2, 3])
s2 = np.array([9, 8, 7])
s3 = np.vstack([s1, s2])
print(s3) #[[1 2 3][9 8 7]]
#Здесь мы создали двумерный массив из двух векторов одинакового размера, которые «поставили» друг на друга.

# То же самое можно сделать и горизонтально:
h1 = np.ones((2, 4))
h2 = np.zeros((2, 2))
h3 = np.hstack((h1, h2))
print(h3) #[[1. 1. 1. 1. 0. 0.][1. 1. 1. 1. 0. 0.]]
#К массиву из единиц справа присоединился массив из нулей. Главное — чтобы количество строк в обоих было одинаковым, иначе вылезет ошибка

#Дополнительные возможности
#NumPy поддерживает другие полезные функции, которые используются реже, но знать о которых полезно. Например, одна из таких функций — чтение файлов с жёсткого диска.
'''
Чтение данных из файла. Допустим, у нас есть файл data.txt с таким содержимым:
1,2,3,5,6,7
8,1,4,2,6,4
9,0,1,7,3,4
Мы можем записать числа в NumPy-массив с помощью функции genfromtxt:
'''
filedata = np.genfromtxt('data.txt', delimiter=',')
filedata = filedata.astype('int32')
print(filedata) #[[1 2 3 5 6 7][8 1 4 2 6 4][9 0 1 7 3 4]]
'''
Сначала мы достали данные из файла data.txt через функцию genfromtxt. В ней нужно указать считываемый файл, а затем разделитель — чтобы NumPy понимал, где начинаются и заканчиваются числа. У нас разделителем будет ,.
Затем нам нужно привести числа к формату int32 с помощью функции astype, передав в неё нужный нам тип.

Булевы выражения. Ещё одна из возможностей NumPy — булевы выражения для элементов массива. Они позволяют узнать, какие элементы отвечают определённым условиям — например, больше ли каждое число массива 50.
Допустим, у нас есть массив a и мы хотим проверить, действительно ли все его элементы больше 5:
'''
c1 = np.array([[1, 5, 8], [3, 4, 2]])
print(c1 > 5) #[[False False  True][False False False]]
#На выходе — массив с «ответом» для каждого элемента: больше ли он числа 5. Если меньше или равно, то стоит False, иначе — True.

#С помощью булевых выражений можно составлять и более сложные конструкции — например, создавать новые массивы из элементов, которые отвечают определённым условиям:
k1 = np.array([[1, 5, 8], [3, 4, 2], [2, 6, 7]])
print(k1[k1 > 3]) #[5 8 4 6 7] Мы получили вектор, состоящий из элементов массива a, которые больше трёх.