#Одним из самых ранних применений генерируемых случайных чисел было вычисление интегралов.Пусть мы генерируем равномерно распределенные
#между a и b случайные числа x1, ..., xn, тогда аппроксимация решения будет найдена как интегрирование по Монте - Карло.
#Мы можем представить выражение(18.1) в виде небольшой программы:

import random as random_number

def MCint(f, a, b, n):
    s = 0
    for i in range(n):
        x = random_number.uniform(a, b)
        s += f(x)
    I = (float(b - a) / n) * s
    return I


#Обычно, достаточная точность метода задается большим числом n, поэтому векторизованная версия будет более удобной:

from numpy import *


def MCint_vec(f, a, b, n):
    x = random.uniform(a, b, n)
    s = sum(f(x))
    I = (float(b - a) / n) * s
    return I


#Рассмотрим интегрирование методом Монте - Карло на примере простой линейной функции
#f(x) = 2 x + 3}, пределы интегрирования — от 1 до 2. Было бы интересно посмотреть как метод справляется с решением задачи для различных n.
# Оценку произведем следующим немного измененным MCint методом:
def MCint2(f, a, b, n):
    s = 0

    I = zeros(n)
    for k in range(1, n + 1):
        x = random_number.uniform(a, b)
        s += f(x)
        I[k - 1] = (float(b - a) / k) * s
    return I

#Заметим, что k изменяется от 1 до n, в то время как индексы I как и раньше идут от 0 до n-1. Поскольку n может быть очень большим,
# массив I может переполнить память. Поэтому следует записывать только каждое N-ое значение аппроксимации. Это возможно с помощью известной
# нам функции определения остатка:
#for k in range(1, n + 1): ... if k % N == 0:

#Итак, каждый раз, когда k делится на N без остатка, мы записываем значение(в нашем случае каждое сотое).Соответствующая функция представлена ниже.
def MCint3(f, a, b, n, N=100):
    '''Cохраняет каждое N приближение интеграла
    в массив I и записываем соответствующее значение k'''
    s = 0

    I_values = []
    k_values = []
    for k in range(1, n + 1):
        x = random_number.uniform(a, b)
        s += f(x)
        if k % N == 0:
            I = (float(b - a) / k) * s
            I_values.append(I)
            k_values.append(k)
    return k_values, I_values


#Теперь у нас есть инструмент для того, чтобы посмотреть как изменяется ошибка в интегрировании методом Монте - Карло с ростом n.
# Законченная программа выглядит следующим образом, результат работы программы(может несколько отличаться ввиду случайности) представлен справа:
# Результат работы программы
import random as random_number
import matplotlib.pyplot as plt
from numpy import array


def MCint3(f, a, b, n, N=100):
    '''Cохраняет каждое N приближение интеграла
    в массив I и записываем соответствующее значение k'''
    s = 0

    I_values = []
    k_values = []
    for k in range(1, n + 1):
        x = random_number.uniform(a, b)
        s += f(x)
        if k % N == 0:
            I = (float(b - a) / k) * s
            I_values.append(I)
            k_values.append(k)
    return k_values, I_values


def f1(x):
    return 2 + 3 * x


k, I = MCint3(f1, 1, 2, 1000000, N=10000)
error = 6.5 - array(I)

plt.title('Monte Carlo integration')
plt.xlabel('n')
plt.ylabel('error')
plt.plot(k, error)
plt.show()