'''
Pyplot - это модуль Matplotlib, который предоставляет простые функции для добавления элементов графика, таких как линии,
изображения, текст и т.Д., К текущим осям на текущем рисунке. Сначала мы настраиваем блокнот для построения и импорта
пакетов, которые мы будем использовать:
'''
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

df = pd.read_csv('happiness_rank.csv')

#plt.style.use('seaborn-whitegrid') # Set the aesthetic style of the plots Фигуру и оси можно создать следующим образом:
fig, ax = plt.subplots()
print(type(fig))
print(type(ax))

'''Мы обычно используем имя переменной fig для ссылки на экземпляр фигуры и ax для ссылки на экземпляр оси или группу 
экземпляров осей. После того, как мы создали оси, мы можем использовать функцию plt.plot для построения некоторых данных.
Возможно, самый простой из всех графиков - это визуализация единственной функции y = 2 x.'''
fig, ax = plt.subplots()
x = np.random.randint(1, 10, size=10)
y = 2 * x
plt.plot(x, y)  # same as ax.plot(x,y)
plt.show()

'''Если мы хотим создать одну фигуру с несколькими линиями, мы можем просто вызвать функцию plot несколько раз:'''
# Multiple lines
fig, ax = plt.subplots()
x = np.random.randint(1, 10, size=10)
y = 2 * x
plt.plot(x, y)
plt.plot(x, x + 3)
plt.show()

'''Цвета и стили линий Функция plt.plot() принимает дополнительные аргументы, которые можно использовать для определения 
цвета и стиля линии.Для настройки мы можем использовать ключевое слово color linestyle, которое принимает строковый 
аргумент, представляющий практически любой вообразимый цвет / стиль.Цвета и стили можно указать разными способами:'''
fig, ax = plt.subplots()
x = np.linspace(0, 10, 1000)
y = 2 * x
# set of default color and style
plt.plot(x, np.cos(x))
# RGB tuple, values 0 to 1, solid style
plt.plot(x, np.sin(x), color=(1.0, 0.2, 0.3), linestyle='-')
# specify color by name, dashed style
plt.plot(x, y, color='blue', linestyle='--')
# short color code (rgbcmyk), dotted style
plt.plot(x, x + 3, color='g', linestyle=':')
# Grayscale between 0 and 1, dashdot style
plt.plot(x, np.log(x), color='0.75', linestyle='-.')
# Hex code (RRGGBB from 00 to FF), dashed style
plt.plot(x, x, color='#FFDD44', linestyle='--')

'''Пределы осей Matplotlib неплохо справляется с выбором пределов осей по умолчанию для нашего графика, но иногда приятно 
иметь более тонкий контроль.Самый простой способ настроить пределы оси - использовать методы plt.xlim() и plt.ylim():'''
plt.xlim(0, 11)
plt.ylim(-1.5, 10)

'''Маркировка графиков В последней части этого раздела мы кратко рассмотрим маркировку графиков: заголовки, 
метки осей и простые легенды.'''
plt.plot(x, np.sin(x), label='y=sin(x)')
plt.plot(x, np.cos(x), label='y=cos(x)')
plt.title('Sine and Cosine Functions ')
plt.xlabel("x-axis")
plt.ylabel("y-axis")
plt.legend()  # Describing the element of the graph
plt.show()

'''Типы участков 
Мы используем набор данных World Happiness Report от Kaggle.Я очистил данные и объединил все файлы в happiness_rank.csv файл.
Диаграмма разброса 
Диаграмма рассеяния - это тип диаграммы, который часто используется в статистике и науке о данных.Он состоит из нескольких 
точек данных, нанесенных на две оси.Каждая переменная, изображенная на диаграмме рассеяния, будет иметь несколько 
наблюдений.Это может быть очень полезным типом диаграммы, когда мы хотим увидеть, есть ли какая - либо связь между двумя 
наборами данных. 
Когда использовать точечные диаграммы 
Мы используем диаграмму рассеяния для определения взаимосвязи данных с каждой переменной(т.Е.Корреляции или 
закономерностей тренда).Это также помогает в обнаружении выбросов на диаграмме. В машинном обучении диаграммы разброса 
часто используются в регрессии, где x и y - непрерывные переменные.Они также используются при кластеризации разбросов 
или обнаружении выбросов. 
Когда следует избегать диаграмм рассеяния 
Диаграммы рассеяния не подходят, если мы заинтересованы в наблюдении временных закономерностей. Диаграмма рассеяния 
используется с числовыми данными или числами.Итак, если у нас есть такие категории, как три подразделения, 
пять продуктов и т.Д., то диаграмма рассеяния мало что покажет. Реализация Python:'''
fig, ax = plt.subplots(figsize=(12, 6))
x = df['GDP']
y = df['Score']
plt.scatter(x, y)
plt.title('GDP vs Happiness Score')
plt.xlabel('GDP')
plt.ylabel('Score')

#Трехмерная диаграмма рассеяния 3 D Scatterplot помогает визуализировать три числовые переменные на трехмерном графике.
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df['Year'], df['GDP'], df['Score'], s=30)
ax.set(xlabel='Year', ylabel='GDP', zlabel='Score')
plt.xticks(np.arange(2015, 2020, step=1))
plt.show()

'''Диаграмма рассеяния с наилучшей линией линейной регрессии 
Мы реализуем линейную регрессию с помощью Scikit - learn, используя LinearRegression.После создания объекта линейной 
регрессии мы можем получить строку, которая лучше всего соответствует нашим данным, вызвав метод fit. '''
x = df['GDP'].values.reshape(-1, 1).astype('float32')
y = df['Score'].values.reshape(-1, 1).astype('float32')
# Split the data to train and test data
X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=0)
# Apply Linear Regression Algorithms
h = LinearRegression()
h.fit(X_train, y_train)
y_pred = h.predict(X_test)
fig, (ax1) = plt.subplots(1, figsize=(12, 6))
ax1.scatter(X_test, y_test, s=8)
plt.plot(X_test, y_pred, color='black', linewidth=2)
plt.show()

'''Расходящиеся бары 
Расходящаяся линейчатая диаграмма - это линейчатая диаграмма, на которой отметки для некоторых элементов измерения 
указывают вверх или вправо, а отметки для других элементов измерения указывают в противоположном направлении(вниз или 
влево, соответственно). Примечание: Спускающиеся вниз или влево отметки не обязательно представляют отрицательные 
значения. Расходящаяся линия может представлять ноль, но ее также можно использовать для простого разделения меток для 
двухмерных элементов. 
Когда использовать расходящиеся полосы 
Мы используем расходящиеся полосы, чтобы увидеть, как элементы меняются в зависимости от одной метрики, и визуализировать 
порядок и величину этого отклонения.Если наша основная цель состоит в том, чтобы сравнить тенденцию каждого члена измерения, 
неплохим вариантом является расходящаяся гистограмма. 
Когда следует избегать расходящихся полос 
Недостатком использования расходящихся столбчатых диаграмм является то, что сравнивать значения по элементам измерения 
не так просто, как с сгруппированной столбчатой диаграммой. 
Реализация Python Мы используем данные за 2019 год только в качестве примера. '''
# Data processing
top_economies = ['United States', 'China', 'Japan', 'Germany', 'United Kingdom', 'India', 'France', 'Brazil', 'Canada']
df_19 = pd.read_csv('2019.csv')
df_19.columns = ['Rank','Country','Score','GDP','Support','Health','Freedom','Generosity','Corruption']
df_top = df_19[(df_19['Country'].isin(top_economies))].sort_values(['Country'])
df_top.reset_index(drop=True)
x = df_top.loc[:, ['Score']]
df_top['Score_z'] = (x - x.mean()) / x.std()
df_top['colors'] = ['red' if x < 0 else 'blue' for x in df_top['Score_z']]
df_top.sort_values('Score_z', inplace=True)
df_top.reset_index(inplace=True)
# Draw plot
plt.figure(figsize=(8, 6), dpi=50)
plt.hlines(y=df_top.index, xmin=0, xmax=df_top.Score_z, color=df_top.colors, alpha=0.5, linewidth=20)
# Decorations
plt.gca().set(ylabel='Country', xlabel='Happiness_Score')
plt.yticks(df_top.index, df_top.Country, fontsize=15)
plt.title('Happiness Score for Top Economies in 2019', fontdict={'size': 20})
plt.grid(linestyle='--', alpha=0.5)
plt.show()

'''Диаграмма с областями 
Идея диаграммы с областями основана на линейной диаграмме.Цветные области(области) показывают 
нам развитие каждой переменной во времени. Существует три типа диаграмм с областями: обычная диаграмма с областями, 
диаграмма с областями с накоплением и диаграмма с областями с накоплением 100 %. 
Когда использовать диаграмму с областями 
Мы используем диаграммы с областями, чтобы показать, как части целого меняются с течением времени.Например, оценка счастья 
состоит из шести порождающих делений; мы хотели бы видеть вклад каждого из этих отделов. Более того, если нас интересует 
часть, сгенерированная каждым подразделением, а не большая часть общей суммы собственного подразделения, мы можем 
использовать диаграмму с областями с накоплением 100 %.Это покажет процентный вклад каждого подразделения с течением 
времени. Когда лучше избегать диаграмм с областями Диаграммы с областями - не лучший выбор, если мы хотим сравнить размер 
разных долей друг с другом.Если вы хотите показать, что одна доля обогнала другую; или если разница между нашими значениями 
очень небольшая, рассмотрите вместо этого линейную диаграмму. Реализация Python'''
# Regular Area Chart
# Create data
x = df_top['Score']
y = df_top['GDP']
# Change the color and its transparency
plt.fill_between(x, y, color="skyblue", alpha=0.2)
plt.xlabel('Score')
plt.ylabel('GDP')
plt.plot(x, y, color="Slateblue", alpha=0.6)

# Stacked Area Chart
plt.stackplot(df_top.index,
              [df_top['GDP'], df_top['Health'],
               df_top['Support'], df_top['Freedom']],
              df_top['Generosity'], df_top['Corruption'],
              labels=['GDP', 'Health', 'Support', 'Freedom', 'Generosity', 'Corruption'],
              alpha=0.8)
plt.legend(loc=2, fontsize='large')
plt.show()

# 100% Stacked Area Chart
data_perc = df_top[['GDP', 'Health', 'Support', 'Freedom', 'Generosity', 'Corruption']]
data_perc = data_perc.divide(data_perc.sum(axis=1), axis=0)
plt.stackplot(data_perc.index,
              [data_perc['GDP'], data_perc['Health'],
               data_perc['Support'], data_perc['Freedom']],
              data_perc['Generosity'], data_perc['Corruption'],
              labels=['GDP', 'Health', 'Support', 'Freedom', 'Generosity', 'Corruption'],
              alpha=0.8)
plt.legend(loc=2, fontsize='large')
plt.show()

'''Гистограмма 
Гистограммы являются одними из наиболее часто используемых типов диаграмм.Как следует из названия, гистограмма состоит 
из серии столбцов, иллюстрирующих развитие переменной. Существует четыре типа линейчатых диаграмм: обычная линейчатая 
диаграмма, горизонтальная линейчатая диаграмма, групповая линейчатая диаграмма и линейчатая диаграмма с накоплением. 
Когда использовать гистограммы 
Гистограммы отлично подходят, когда мы хотим отслеживать развитие одной или двух переменных с течением времени.
Одна ось диаграммы показывает конкретные сравниваемые категории, а другая ось представляет измеренное значение. 
Когда следует избегать гистограмм 
Простая гистограмма не подходит, когда у нас есть разбивка переменной за один период.Например, если я хочу изобразить 
основные направления бизнеса, которые внесли вклад в доходы компании, я бы не использовал гистограмму.Вместо этого я бы 
создал круговую диаграмму или один из ее вариантов. Python Implementation'''
# Bar Chart
countries = ['United States', 'Japan', 'Germany', 'Brazil', 'India']
y_pos = np.arange(len(countries))
data = df_19[(df_19['Country'].isin(countries))].sort_values(['Country'])
data.sort_values('GDP', inplace=True)
data.reset_index(drop=True)
plt.bar(y_pos, data['GDP'], align='center', alpha=0.5)
plt.xticks(y_pos, data['Country'])
plt.ylabel('GDP')
plt.title('Bar Chart')
plt.show()

# Horizontal bar chart
df_19[(df_19['Country'].isin(countries))].sort_values(['Country'])
data.sort_values('Score', inplace=True)
data.reset_index(drop=True)
plt.barh(y_pos, data['Score'], align='center', alpha=0.5)
plt.yticks(y_pos, data['Country'])
plt.xlabel('Score')
plt.title('Horizontal Bar Chart')
plt.show()

# Group bar chart
index = np.arange(5)
width = 0.35
fig, ax = plt.subplots(figsize=(9, 6))
rects1 = ax.bar(index - width / 2, data['GDP'],width, color='#1f77b4', alpha=0.5)
rects2 = ax.bar(index + width / 2, data['Health'],width, color='#1f77b4')
#plt.xticks(index, gdp['Country'])
plt.legend((rects1[0], rects2[0]), ('GDP', 'Health'))
plt.show()

# Stacked bar chart
fig = plt.figure(figsize=(14, 10))
rect1 = plt.bar(np.arange(5), data['Support'],width=0.5, color='lightblue')
rect2 = plt.bar(np.arange(5), data['Freedom'],width=0.5, color='#1f77b4')
plt.xticks(index, data['Country'])
plt.legend((rect1[0], rect2[0]), ('Support', 'Freedom'))
plt.show()

''''Диаграмма леденца на палочке 
График Lollipop служит той же цели, что и упорядоченная гистограмма, и выглядит приятным на вид.Мы используем диаграммы 
леденца на палочке, чтобы показать взаимосвязь между числовой переменной и другой числовой или категориальной переменной. 
Когда использовать диаграммы леденца на палочке Часто утверждают, что диаграмма «леденец» полезна по сравнению с обычной 
гистограммой, если мы имеем дело с большим количеством значений и когда все значения высокие, например, в диапазоне 
80–90 % (из 100 %).Тогда большой набор высоких колонн может быть визуально агрессивным. 
Когда следует избегать диаграмм с леденцами 
Если в наших данных есть несортированные столбцы очень похожей длины - сложнее сравнивать длину двух очень похожих 
леденцов на палочке, чем стандартные столбцы. Реализация Python '''
(markerline, stemlines, baseline) = plt.stem(data['Country'],data['GDP'])
plt.setp(markerline, marker='o', markersize=15,markeredgewidth=2, color='lightblue')
plt.setp(stemlines, color='lightblue')
plt.setp(baseline, visible=False)
plt.tick_params(labelsize=12)
plt.ylabel('GDP', size=12)
plt.ylim(bottom=0)
plt.show()

''''Гистограмма 
Гистограмма - это вертикальная гистограмма, которая отображает распределение набора данных.Гистограммы используются для 
отображения распределения переменных, а гистограммы используются для сравнения переменных.Гистограммы отображают 
количественные данные с диапазонами данных, сгруппированными в ячейки или интервалы, в то время как гистограммы отображают 
категориальные данные. Примечание.На гистограммах между столбцами есть пробелы, а на гистограммах - нет. Гистограммы удобны, 
когда мы хотим показать распределение данных, с которыми мы работаем.Это позволяет нам группировать непрерывные данные в 
интервалы и, следовательно, обеспечивать полезное представление о том, где сосредоточены наблюдения. Реализация Python'''
# Histogram
fig = plt.figure(figsize=(8, 6))
plt.hist(df_19['Corruption'], bins=6, density=True)
plt.grid(alpha=0.2)
plt.show()

''''Коробчатые диаграммы(диаграммы усов) 
Ящичная диаграмма или диаграмма усов - это способ суммирования набора данных, измеренных на интервальной шкале.Этот тип 
графика используется для отображения формы распределения, его центрального значения и его изменчивости. 
Когда использовать коробчатые диаграммы 
Мы используем коробчатые диаграммы в пояснительном анализе данных, показывая, искажено ли распределение и есть ли в наборе 
данных потенциальные необычные наблюдения(выбросы). Коробчатые диаграммы также очень полезны, когда задействовано большое 
количество наблюдений и когда сравниваются два или более наборов данных. 
Когда следует избегать коробчатых диаграмм 
Коробчатые диаграммы не показывают распределение так подробно, как диаграмма стеблей и листьев или гистограмма. 
Реализация Python Предположим, у нас есть набор данных, содержащий количество статей, прочитанных участниками Medium за 
первые шесть месяцев 2020 года.'''
# Create dataset
user_1 = [10, 3, 15, 21, 17, 14]
user_2 = [5, 13, 10, 7, 9, 12]
data = [user_1, user_2]
fig = plt.figure(figsize=(8, 6))

# Create axes instance
ax = fig.add_axes([0, 0, 1, 1])

# Create plot
bp = ax.boxplot(data)

# Show plot
plt.xticks([1, 2], ['user_1', 'user_2'])
plt.show()

''''Круговые диаграммы 
Круговые диаграммы - это классический способ показать состав групп.Круговая диаграмма - это круговой график, разделенный 
на части.Чем больше срез, тем большую часть от общего количества он представляет. Однако в настоящее время обычно не 
рекомендуется использовать, потому что площадь порций пирога иногда может вводить в заблуждение.Поэтому при использовании 
круговых диаграмм настоятельно рекомендуется явно записывать процент или числа для каждой части круговой диаграммы. 
Когда использовать круговые диаграммы 
Круговые диаграммы лучше всего подходят для отображения частей целого. 
Когда следует избегать круговых диаграмм 
Мы не можем использовать круговую диаграмму в ситуациях, когда мы хотим показать, как одна или несколько переменных 
развиваются с течением времени. Реализация Python Предположим, у нас есть набор данных, содержащий информацию о членах 
Medium.Мы хотим увидеть процент прочитанных статей в первые шесть месяцев 2020 года. '''
# Pie Chart
fig = plt.figure(figsize=(8, 8))
labels = 'Jan', 'Feb', 'March', 'April', 'May', 'June'
user_1 = [10, 3, 15, 21, 17, 14]
p = plt.pie(user_1, labels=labels, explode=(0.07, 0, 0, 0, 0, 0),autopct='%1.1f%%', startangle=130, shadow=True)
plt.axis('equal')
for i, (Jan, Feb, March, April, May, June) in enumerate(p):
    if i > 0:
        Jan.set_fontsize(12)
        Feb.set_fontsize(12)
        March.set_fontsize(12)
        April.set_fontsize(12)
        May.set_fontsize(12)
        June.set_fontsize(12)
plt.show()

''''Диаграммы древовидной карты 
Древовидная диаграмма похожа на круговую диаграмму и работает лучше, не вводя в заблуждение вклад каждой группы.Диаграмма 
древовидной карты позволяет нам разделить сумму целого на иерархии, а затем показать внутреннюю разбивку каждой из этих иерархий. 
Когда использовать диаграммы Treemap 
Древовидные карты часто используются для данных о продажах, поскольку они фиксируют относительные размеры категорий 
данных, что позволяет быстро получить высокоуровневую сводку сходств и аномалий внутри одной категории, а также между 
несколькими категориями. 
Когда следует избегать использования диаграмм Treemap 
Диаграммы древовидной карты не подходят, если наши данные не делятся на категории и подкатегории. Более того, когда мы 
кодируем данные по площади и интенсивности цвета, наши глаза не очень хорошо обнаруживают относительно незначительные 
различия в любом из этих параметров.Если наши данные таковы, что нашей аудитории необходимо проводить точные сравнения 
между категориями, это становится еще более громоздким, когда категории не соответствуют общему базовому уровню.Мы 
никогда не должны заставлять нашу аудиторию работать больше, чем необходимо для понимания графика! Реализация Python 
Например, мы используем древовидную диаграмму, чтобы представить новых пользователей и просмотреть статьи в этом месяце.'''

import squarify

fig = plt.figure(figsize=(10, 10))
articles = [17, 22, 35, 41, 5, 12, 47]
labels = ['User_1:\n 17 articles',
          'User_2:\n 22 articles',
          'User_3:\n 35 articles',
          'User_4:\n 41 articles',
          'User_5:\n 5 articles',
          'User_6:\n 12 articles',
          'User_7:\n 47 articles']
color_list = ['#0f7216', '#b2790c', '#ffe9a3',
              '#f9d4d4', '#d35158', '#ea3033']
plt.rc('font', size=14)
squarify.plot(sizes=articles, label=labels,
              color=color_list, alpha=0.7)
plt.axis('off')
plt.show()

''''График временных рядов 
Графики временных рядов можно использовать для визуализации тенденций в подсчетах или числовых значениях с течением 
времени. Поскольку информация о дате и времени представляет собой непрерывные категориальные данные(выраженные в виде 
диапазона значений), точки наносятся на график по оси x и соединяются непрерывной линией. Цель анализа временных рядов -
 найти закономерности в данных и использовать их для прогнозов.Графики временных рядов могут ответить на такие вопросы 
 о наших данных, как: Как меняется тренд с течением времени? Реализация Python'''
# Time Series Plot
plt.figure(figsize=(8, 6))
ts = pd.Series(np.random.randn(100), index=pd.date_range(
    '1/1/2020', periods=100))
# Return the cumulative sum of the elements.
ts = ts.cumsum()
ts.plot()
plt.show()
